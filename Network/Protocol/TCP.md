TCP协议
==

> 参考文章

> https://zhuanlan.zhihu.com/p/199284611

> https://zhuanlan.zhihu.com/p/144273871


## 三次握手

#### 建立连接初始化的目标
- 分配资源
- 初始化序列号(通知 peer 对端我的初始序列号是多少)

#### TCP连接次数的问题
正常情况下需要 4个步骤，但是其中 服务端ACK以及服务端SYN的步骤可以合并，这样的话能节省资源
三次握手在进行最少次交互的情况下完成了 Peer 两端的资源分配和初始化序列号的交换

#### 步骤
- A发起连接(connect())： SYN seq=x
- - A进入状态 SYN_SENT
- B接收到数据后发起SYN+ACK(listen())： SYN=y,ACK=x+1
- - B进入状态 SYN_RCVD
- A接收到B的SYN后再次ACK：ACK=y+1
- - A进入ESTABLISHED
- - B收到之后也进入ESTABLISHED

#### 为什么两次不行
两次的情况下，AB两个端，假设建立连接是A发起的，A通过B的ACK达成了A的发送序列号的一致
但是AB之间无法对B的序列号达成一致

有两个关键点需要注意：
- TCP对有数据的TCP segment 必须确认（segment段，国内也称呼为包）
- TCP不会为没有数据的ACK超时重传

SYN这个同步标志位SYN设计成占用一个字节的编号（FIN标志位也是），既然有了数据那就必须给回应
B如果没有收到A的ACK，会超时重传自己的SYN同步信号，一直到收到A的ACK为止
在此期间B会因为一直超时重传而不能主动发送数据

#### 问题引申：序列号的作用与意义
ISN:初始化序列号（initial sequence number），是在建立tcp三次连接的时候，存储在序列号位置中的数字的代称。
也就是说，告诉对方我将要开始发送的初始化序列号是多少，两边都要发这个ISN，即tcp三次连接中第一个SYN包和第二个SYN+ACK的包都有这个。

TCP 的可靠连接是靠 seq（ sequence numbers 序列号）来达成的。
TCP 设计中一个基本设定就是，通过TCP 连接发送的每一个包，都有一个sequence number。
而因为每个包都是有序列号的，所以都能被确认收到这些包。
确认机制是累计的，所以一个对sequence number X 的确认，意味着 X 序列号之前(不包括 X) 包都是被确认接收到的。

当一个新连接建立时，初始序列号（ initial sequence number ISN）生成器会生成一个新的32位的 ISN。
这个生成器会用一个32位长的时钟，差不多4µs 增长一次，因此 ISN 会在大约 4.55 小时循环一次（2^32位的计数器，需要2^32*4 µs才能自增完，除以1小时共有多少µs便可算出2^32*4 /(1*60*60*1000*1000)=4.772185884 ）
而一个段在网络中并不会比最大分段寿命（Maximum Segment Lifetime (MSL) ，默认使用2分钟）长，
MSL 比4.55小时要短，所以我们可以认为 ISN 会是唯一的。
发送方与接收方都会有自己的 ISN 来做双方互发通信


## 四次挥手

#### TCP 进行断开连接的目标是：
- 回收资源
- 终止数据传输

由于 TCP 是全双工的，需要 Peer 两端分别各自拆除自己通向 Peer 对端的方向的通信信道。
这样需要四次挥手来分别拆除通信信道。

#### 流程
- A发起关闭：FIN seq=x, ACK=y(该值是最后一次数据交换该ACK的值)
- - A进入 FIN_WAIT_1
- B接收到信号，发起ACK： ACK=x+1
- - B进入 CLOSE_WAIT
- - A进入 FIN_WAIT_2
- B剩余数据发送完之后发起FIN：FIN seq=y
- - B进入 LAST_ACK
- A接收到B的关闭之后发起ACK：ACK=y+1
- - A进入TIME_WAIT（主动关闭方需要进入 TIME_WAIT 以便能够重发丢掉的被动关闭方 FIN 的 ACK）
- - B接收到ACK之后进入 CLOSED状态

#### TIME_WAIT 状态是用来解决或避免什么问题呢
- 主动关闭方需要进入 TIME_WAIT 以便能够重发丢掉的被动关闭方 FIN 包的 ACK
- 防止已经断开的连接 1 中在链路中残留的 FIN 包终止掉新的连接 2
- 防止链路上已经关闭的连接的残余数据包(a lost duplicate packet or a wandering duplicate packet) 干扰正常的数据包，造成数据流的不正常。这个问题和 2）类似

#### TIME_WAIT 会导致很多问题
TIME_WAIT 带来的问题注意是源于：一个连接进入 TIME_WAIT 状态后需要等待 2*MSL(一般是 1 到 4 分钟)那么长的时间才能断开连接释放连接占用的资源

问题如下
- 作为服务器，短时间内关闭了大量的 Client 连接，就会造成服务器上出现大量的 TIME_WAIT 连接，占据大量的 tuple，严重消耗着服务器的资源。
- 作为客户端，短时间内大量的短连接，会大量消耗的 Client 机器的端口，毕竟端口只有 65535 个，端口被耗尽了，后续就无法在发起新的连接了。
由于上面两个问题，作为客户端需要连本机的一个服务的时候，首选 UNIX 域套接字而不是 TCP)

#### TIME_WAIT 问题的缓解方案
- TIME_WAIT 的快速回收
- - linux下有参数配置可以使用快速回收，但是可能导致一系列问题
- TIME_WAIT重用

Linux下TIME_WAIT重用条件
- 新连接 SYN 告知的初始序列号比 TIME_WAIT 老连接的末序列号大；
- 如果开启了 tcp_timestamps，并且新到来的连接的时间戳比老连接的时间戳大

要同时开启 tcp_tw_reuse 选项和 tcp_timestamps 选项才可以开启 TIME_WAIT 重用，
还有一个条件是：重用 TIME_WAIT 的条件是收到最后一个包后超过 1s

## 数据传输

#### 超时重传

##### 超时重传时间
先了解两个概念：
RTT与RTO
- RTT（Round Trip Time） 一个数据包从发出去到回来的时间 
- RTO（Retransmission TimeOut）超时重传时间

RTO的计算比较复杂，此处就略过了，但是经过改进，也解决了一些网络抖动带来的问题

##### TCP 的重传机制（重传哪些包）
ACK会一直回复 第一个未收到的包的序列号。如果有多个包丢失，在此基础上发送端丢失包的重传有两个选择。

- A：重传第一个未收到的包
- B：重传后面所有的包

以上两个方法个有优劣。
在此基础上，RFC2018 提出了 Selective Acknowledgment(SACK，选择确认)机制，
SACK 是 TCP 的扩展选项，包括(1)SACK 允许选项（Kind=4,Length=2，选项只允许在有 SYN 标志的 TCP 包中），
(2)SACK 信息选项 Kind=5,Length）。

#### 流量控制

##### 滑动窗口
发送方要知道那些可以发，哪些不可以发，一个简明的方案就是按照接收方的窗口通告，
发送方维护一个一样大小的发送窗口就可以了，在窗口内的可以发，窗口外的不可以发，
窗口在发送序列上不断后移，这就是 TCP 中的滑动窗口。
这个窗口是接收端告诉发送端自己还有多少**缓冲区**可以接收数据。

> 重点标记：窗口大小维护和接收端的缓冲区有直接关系

滑动窗口由接收方控制，在数据ACK的时候，同时带上窗口大小信息。
如果服务端返回zero的零窗口，客户端的窗口也变成0，这样的话 ，会导致一个问题，发送不了数据
TCP解决这个问题，客户端主动发 ZWP（Zero Window Probe） 包给接收方，来探测目前接收端的窗口大小，一般这个值会设置成 3 次，每次大约 30-60 秒（不同的实现可能会不一样）


对于 TCP 发送端其发送缓存内的数据都可以分为 4 类：
- 1 已经发送并得到接收端 ACK 的； 
- 2 已经发送但还未收到接收端 ACK 的；
- 3 未发送但允许发送的(接收方还有空间)；
- 4 未发送且不允许发送(接收方没空间了)。
其中，2和3两部分合起来称之为发送窗口


## 拥塞控制
由于 TCP 看不到网络的状况，那么拥塞控制是必须的并且需要采用试探性的方式来控制拥塞，
于是拥塞控制要完成两个任务：
- 公平性
- 拥塞过后的恢复

TCP 发展到现在，拥塞控制方面的算法很多，其中 Reno 是目前应用最广泛且较为成熟的算法，下面着重介绍一下 Reno 算法(RFC5681)。

Reno 算法包含 4 个部分：
- 慢热启动算法 – Slow Start；
- 拥塞避免算法 – Congestion Avoidance；
- 快速重传 - Fast Retransimit；
- 快速恢复算法 – Fast Recovery。

先理解一个概念MSS：MSS，最大报文段长度。
在连接建立的时候，即在发送SYN段的时候，同时会将MSS发送给对方（MSS选项只能出现在SYN段中！！！），
告诉对端他期望接收的TCP报文段数据部分最大长度。（这个和数据链路层的帧大小有关）

TCP 的拥塞控制主要原理依赖于一个拥塞窗口(cwnd (全称Congestion Window))来控制，根据前面的讨论，我们知道有一个接收端通告的接收窗口(rwnd)用于流量控制；
加上拥塞控制后，发送端真正的发送窗口=min(rwnd,cwnd)。
关于 cwnd 的单位，在 TCP 中是以字节来做单位的，我们假设 TCP 每次传输都是按照 MSS 大小来发送数据，
因此你可以认为 cwnd 按照数据包个数来做单位也可以理解，下面如果没有特别说明是字节，
那么 cwnd 增加 1 也就是相当于字节数增加 1 个 MSS 大小。

##### 慢热启动算法 流程
- 连接建好的开始先初始化 cwnd = N，表明可以传 N 个 MSS 大小的数据；
- 每当收到一个 ACK，++cwnd; 呈线性上升； 
- 每当过了一个 RTT，cwnd = cwnd*2; 呈指数让升；
- 还有一个慢启动门限 ssthresh（slow start threshold），是一个上限，当 cwnd >= ssthresh 时，就会进入"拥塞避免算法 - Congestion Avoidance"

##### 拥塞避免
慢启动的时候说过，cwnd 是指数快速增长的，但是增长是有个门限 ssthresh(一般来说大多数的实现 ssthresh 的值是 65535 字节)的，到达门限后进入拥塞避免阶段

- 每收到一个 ACK，调整 cwnd 为 (cwnd + 1/cwnd) * MSS 个字节；
- 每经过一个 RTT 的时长，cwnd 增加 1 个 MSS 大小
 
TCP 是看不到网络的整体状况的，那么 TCP 认为网络拥塞的主要依据是它重传了报文段

- 出现 RTO 超时，重传数据包 时候，这种情况下，TCP 就认为出现拥塞的可能性就很大，于是它反应非常'强烈' 
- - 调整门限 ssthresh 的值为当前 cwnd 值的 1/2；
- - reset 自己的 cwnd 值为 1；
- - 然后重新进入慢启动过程。
- 在 RTO 超时前，收到 3 个 duplicate ACK 进行重传数据包
- - 此时拥塞窗口缩小的幅度就不能太大，此时进入快速重传

##### 快速重传
- 调整门限 ssthresh 的值为当前 cwnd 值的 1/2；
- 将 cwnd 值设置为新的 ssthresh 的值；
- 重新进入拥塞避免阶段

在此基础上，“快速恢复”算法被添加进来，当收到 3 个冗余 ACK 时，TCP 最后的 3步骤进入的不是拥塞避免阶段、
，而是快速恢复阶段

##### 快速恢复
在进入快速恢复前，cwnd 和 sshthresh 已被更新为：sshthresh = cwnd /2，cwnd = sshthresh

而后的步骤如下：
- 把 cwnd 设置为 ssthresh 的值加 3，重传 Duplicated ACKs 指定的数据包
- 如果再收到 duplicated Acks，那么 cwnd = cwnd +1；
- 如果收到新的 ACK，而非 duplicated Ack，那么将 cwnd 重新设置为【快速重传】中 1）的 sshthresh 的值。然后进入拥塞避免状态


我们可以看到，拥塞控制在拥塞避免阶段，cwnd 是加性增加的，在判断出现拥塞的时候采取的是指数递减。
这主要是考虑缓慢增速受惠的是自己，而遇到堵塞，则快速让出带宽，可以给其他新建的连接腾出足够的带宽空间，从而保证整个的公平性。

## 总结

总的来说 TCP 是一个有连接的、可靠的、带流量控制和拥塞控制的端到端的协议

TCP 的发送窗口稳定状态：
- 接收端拥有大窗口的经典锯齿状
- - 大多数情况下都是处于这样的稳定状态
- - 在拥塞控制的多个阶段滚动切换
- 接收端拥有小窗口的直线状态
- - 这种情况下是接收端非常慢速，接收窗口一直很小，这样发送窗口就完全有接收窗口决定了
- 两个直连网络端点间的满载状态下的直线状态
- - 直连跑满带宽


## 与UDP区别

- 连接
- - TCP是面向连接的有状态的协议
- - UDP是无连接的无状态的协议
- 数据报文
- - TCP：字节流
- - UDP：报文
- 效率
- - TCP效率要低于UDP
- 双工性
- - TCP全双工
- - UDP 一对一、一对多、多对一、多对多
- 流量控制与拥塞控制
- - TCP有，UDP无